<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><title>thornton | Generating signed distance fields for rendering vector graphics</title><link rel=stylesheet href=/css/fonts.css><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body><div class=sidebar><div class="container sidebar-sticky"><div class=sidebar-about><h1>thornton</h1><p class=lead></p></div><nav class=sidebar-nav><a class=sidebar-nav-item href=/><span>home</span></a>
<a class=sidebar-nav-item href=/about><span>about</span></a>
<a class=sidebar-nav-item href=/projects><span>projects</span></a>
<a class=sidebar-nav-item href=/posts/><span>posts</span></a></nav></div></div><div id=content-wrapper><div id=content><h1 id=generating-signed-distance-fields-for-rendering-vector-graphics>Generating Signed Distance Fields for rendering vector graphics</h1><p>Note: for this post I will mainly be talking about rendering text, but the technique can be used for any form vector graphics.</p><h2 id=1-what--why>1. What & Why</h2><h3 id=the-problem>The problem:</h3><p>The simplest way to render text is to draw all the characters onto a texture and simply sample from that texture. Lets say we want our texture to be 2048 x 2048 pixels, so each character can be about 180 x 180.</p><p>The easiest way is to say, if our pixel is inside the character, its white otherwise its black.
But we can see the result is VERY choppy, and when it gets upscaled the choppyness stays.</p><p><a class=lightbox href=#letter_2048.png><img src=./img/letter_2048.png class=small></a>
<a href=# class=lightbox-target id=letter_2048.png class=lightbox-target><img src=./img/letter_2048.png></a>
<a class=lightbox href=#letter_2048_linear.png><img src=./img/letter_2048_linear.png class=small></a>
<a href=# class=lightbox-target id=letter_2048_linear.png class=lightbox-target><img src=./img/letter_2048_linear.png></a></p><p>We can improve that by calculating how much the pixel is inside the shape and storing that instead of just white or black.
This smooths things out at resolutions smaller than our target, but once again upscaling makes things a blurry mess.</p><p><a class=lightbox href=#letter_2048_AA.png><img src=./img/letter_2048_AA.png class=small></a>
<a href=# class=lightbox-target id=letter_2048_AA.png class=lightbox-target><img src=./img/letter_2048_AA.png></a>
<a class=lightbox href=#letter_2048_AA_linear.png><img src=./img/letter_2048_AA_linear.png class=small></a>
<a href=# class=lightbox-target id=letter_2048_AA_linear.png class=lightbox-target><img src=./img/letter_2048_AA_linear.png></a></p><p>Now of course we could improve this by rendering our characters at higher resolutions, but in order to keep our letters looking as sharp as possible, we would have to render at the highest possible resolution they could be displayed at.
This is not feasible. If we were to target a 1080p monitor and render our characters that tall we would need at least 100 MB to store an entire font style. Thats a significant amount of storage considering we need to duplicate that for every font STYLE. That means if we have we have just one font with bold, italic and regular we would use more than a 3rd of a GB.</p><p>If we were to target a 4k monitor and render our characters that tall we would need 14 MB to store each character and 1.8 GB to store a whole font</p><p>Crisp 4k A</p><a class=lightbox href=#letter_4k.png><img src=./img/letter_4k.png class=small></a>
<a href=# class=lightbox-target id=letter_4k.png class=lightbox-target><img src=./img/letter_4k.png></a>
<a class=lightbox href=#dist_vs_pixel.png><img src=./img/dist_vs_pixel.png class=medium></a>
<a href=# class=lightbox-target id=dist_vs_pixel.png class=lightbox-target><img src=./img/dist_vs_pixel.png></a><p>    </p><h3 id=the-solution>The solution</h3><p>//very basic description of sdf</p><p>//description of how pixels are interpolated and how that works with sdf</p><p>//description of how sdf are actually rendered</p><p>//circle visualization diagram</p><p>//bonus features of sdfs</p><h2 id=2-how>2. How</h2><p>//how I actually went about generating the sdfs</p></div></div></body></html>